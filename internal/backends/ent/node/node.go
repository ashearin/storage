// Code generated by ent, DO NOT EDIT.
// --------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2024 The Protobom Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// --------------------------------------------------------------

package node

import (
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the node type in the database.
	Label = "node"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldFromNodeID holds the string denoting the from_node_id field in the database.
	FieldFromNodeID = "from_node_id"
	// FieldNodeListID holds the string denoting the node_list_id field in the database.
	FieldNodeListID = "node_list_id"
	// FieldType holds the string denoting the type field in the database.
	FieldType = "type"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldVersion holds the string denoting the version field in the database.
	FieldVersion = "version"
	// FieldFileName holds the string denoting the file_name field in the database.
	FieldFileName = "file_name"
	// FieldURLHome holds the string denoting the url_home field in the database.
	FieldURLHome = "url_home"
	// FieldURLDownload holds the string denoting the url_download field in the database.
	FieldURLDownload = "url_download"
	// FieldLicenses holds the string denoting the licenses field in the database.
	FieldLicenses = "licenses"
	// FieldLicenseConcluded holds the string denoting the license_concluded field in the database.
	FieldLicenseConcluded = "license_concluded"
	// FieldLicenseComments holds the string denoting the license_comments field in the database.
	FieldLicenseComments = "license_comments"
	// FieldCopyright holds the string denoting the copyright field in the database.
	FieldCopyright = "copyright"
	// FieldSourceInfo holds the string denoting the source_info field in the database.
	FieldSourceInfo = "source_info"
	// FieldComment holds the string denoting the comment field in the database.
	FieldComment = "comment"
	// FieldSummary holds the string denoting the summary field in the database.
	FieldSummary = "summary"
	// FieldDescription holds the string denoting the description field in the database.
	FieldDescription = "description"
	// FieldReleaseDate holds the string denoting the release_date field in the database.
	FieldReleaseDate = "release_date"
	// FieldBuildDate holds the string denoting the build_date field in the database.
	FieldBuildDate = "build_date"
	// FieldValidUntilDate holds the string denoting the valid_until_date field in the database.
	FieldValidUntilDate = "valid_until_date"
	// FieldAttribution holds the string denoting the attribution field in the database.
	FieldAttribution = "attribution"
	// FieldFileTypes holds the string denoting the file_types field in the database.
	FieldFileTypes = "file_types"
	// FieldEdgeType holds the string denoting the edge_type field in the database.
	FieldEdgeType = "edge_type"
	// EdgeSuppliers holds the string denoting the suppliers edge name in mutations.
	EdgeSuppliers = "suppliers"
	// EdgeOriginators holds the string denoting the originators edge name in mutations.
	EdgeOriginators = "originators"
	// EdgeExternalReferences holds the string denoting the external_references edge name in mutations.
	EdgeExternalReferences = "external_references"
	// EdgeIdentifiers holds the string denoting the identifiers edge name in mutations.
	EdgeIdentifiers = "identifiers"
	// EdgeHashes holds the string denoting the hashes edge name in mutations.
	EdgeHashes = "hashes"
	// EdgePrimaryPurpose holds the string denoting the primary_purpose edge name in mutations.
	EdgePrimaryPurpose = "primary_purpose"
	// EdgeFromNode holds the string denoting the from_node edge name in mutations.
	EdgeFromNode = "from_node"
	// EdgeNodes holds the string denoting the nodes edge name in mutations.
	EdgeNodes = "nodes"
	// EdgeNodeList holds the string denoting the node_list edge name in mutations.
	EdgeNodeList = "node_list"
	// Table holds the table name of the node in the database.
	Table = "nodes"
	// SuppliersTable is the table that holds the suppliers relation/edge.
	SuppliersTable = "persons"
	// SuppliersInverseTable is the table name for the Person entity.
	// It exists in this package in order to avoid circular dependency with the "person" package.
	SuppliersInverseTable = "persons"
	// SuppliersColumn is the table column denoting the suppliers relation/edge.
	SuppliersColumn = "node_suppliers"
	// OriginatorsTable is the table that holds the originators relation/edge.
	OriginatorsTable = "persons"
	// OriginatorsInverseTable is the table name for the Person entity.
	// It exists in this package in order to avoid circular dependency with the "person" package.
	OriginatorsInverseTable = "persons"
	// OriginatorsColumn is the table column denoting the originators relation/edge.
	OriginatorsColumn = "node_id"
	// ExternalReferencesTable is the table that holds the external_references relation/edge.
	ExternalReferencesTable = "external_references"
	// ExternalReferencesInverseTable is the table name for the ExternalReference entity.
	// It exists in this package in order to avoid circular dependency with the "externalreference" package.
	ExternalReferencesInverseTable = "external_references"
	// ExternalReferencesColumn is the table column denoting the external_references relation/edge.
	ExternalReferencesColumn = "node_id"
	// IdentifiersTable is the table that holds the identifiers relation/edge.
	IdentifiersTable = "identifiers_entries"
	// IdentifiersInverseTable is the table name for the IdentifiersEntry entity.
	// It exists in this package in order to avoid circular dependency with the "identifiersentry" package.
	IdentifiersInverseTable = "identifiers_entries"
	// IdentifiersColumn is the table column denoting the identifiers relation/edge.
	IdentifiersColumn = "node_identifiers"
	// HashesTable is the table that holds the hashes relation/edge.
	HashesTable = "hashes_entries"
	// HashesInverseTable is the table name for the HashesEntry entity.
	// It exists in this package in order to avoid circular dependency with the "hashesentry" package.
	HashesInverseTable = "hashes_entries"
	// HashesColumn is the table column denoting the hashes relation/edge.
	HashesColumn = "node_hashes"
	// PrimaryPurposeTable is the table that holds the primary_purpose relation/edge.
	PrimaryPurposeTable = "purposes"
	// PrimaryPurposeInverseTable is the table name for the Purpose entity.
	// It exists in this package in order to avoid circular dependency with the "purpose" package.
	PrimaryPurposeInverseTable = "purposes"
	// PrimaryPurposeColumn is the table column denoting the primary_purpose relation/edge.
	PrimaryPurposeColumn = "node_id"
	// FromNodeTable is the table that holds the from_node relation/edge.
	FromNodeTable = "nodes"
	// FromNodeColumn is the table column denoting the from_node relation/edge.
	FromNodeColumn = "from_node_id"
	// NodesTable is the table that holds the nodes relation/edge.
	NodesTable = "nodes"
	// NodesColumn is the table column denoting the nodes relation/edge.
	NodesColumn = "from_node_id"
	// NodeListTable is the table that holds the node_list relation/edge.
	NodeListTable = "nodes"
	// NodeListInverseTable is the table name for the NodeList entity.
	// It exists in this package in order to avoid circular dependency with the "nodelist" package.
	NodeListInverseTable = "node_lists"
	// NodeListColumn is the table column denoting the node_list relation/edge.
	NodeListColumn = "node_list_id"
)

// Columns holds all SQL columns for node fields.
var Columns = []string{
	FieldID,
	FieldFromNodeID,
	FieldNodeListID,
	FieldType,
	FieldName,
	FieldVersion,
	FieldFileName,
	FieldURLHome,
	FieldURLDownload,
	FieldLicenses,
	FieldLicenseConcluded,
	FieldLicenseComments,
	FieldCopyright,
	FieldSourceInfo,
	FieldComment,
	FieldSummary,
	FieldDescription,
	FieldReleaseDate,
	FieldBuildDate,
	FieldValidUntilDate,
	FieldAttribution,
	FieldFileTypes,
	FieldEdgeType,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

var (
	// IDValidator is a validator for the "id" field. It is called by the builders before save.
	IDValidator func(string) error
)

// Type defines the type for the "type" enum field.
type Type string

// Type values.
const (
	TypePACKAGE Type = "PACKAGE"
	TypeFILE    Type = "FILE"
)

func (_type Type) String() string {
	return string(_type)
}

// TypeValidator is a validator for the "type" field enum values. It is called by the builders before save.
func TypeValidator(_type Type) error {
	switch _type {
	case TypePACKAGE, TypeFILE:
		return nil
	default:
		return fmt.Errorf("node: invalid enum value for type field: %q", _type)
	}
}

// EdgeType defines the type for the "edge_type" enum field.
type EdgeType string

// EdgeType values.
const (
	EdgeTypeUNKNOWN              EdgeType = "UNKNOWN"
	EdgeTypeAmends               EdgeType = "amends"
	EdgeTypeAncestor             EdgeType = "ancestor"
	EdgeTypeBuildDependency      EdgeType = "buildDependency"
	EdgeTypeBuildTool            EdgeType = "buildTool"
	EdgeTypeContains             EdgeType = "contains"
	EdgeTypeContainedBy          EdgeType = "contained_by"
	EdgeTypeCopy                 EdgeType = "copy"
	EdgeTypeDataFile             EdgeType = "dataFile"
	EdgeTypeDependencyManifest   EdgeType = "dependencyManifest"
	EdgeTypeDependsOn            EdgeType = "dependsOn"
	EdgeTypeDependencyOf         EdgeType = "dependencyOf"
	EdgeTypeDescendant           EdgeType = "descendant"
	EdgeTypeDescribes            EdgeType = "describes"
	EdgeTypeDescribedBy          EdgeType = "describedBy"
	EdgeTypeDevDependency        EdgeType = "devDependency"
	EdgeTypeDevTool              EdgeType = "devTool"
	EdgeTypeDistributionArtifact EdgeType = "distributionArtifact"
	EdgeTypeDocumentation        EdgeType = "documentation"
	EdgeTypeDynamicLink          EdgeType = "dynamicLink"
	EdgeTypeExample              EdgeType = "example"
	EdgeTypeExpandedFromArchive  EdgeType = "expandedFromArchive"
	EdgeTypeFileAdded            EdgeType = "fileAdded"
	EdgeTypeFileDeleted          EdgeType = "fileDeleted"
	EdgeTypeFileModified         EdgeType = "fileModified"
	EdgeTypeGenerates            EdgeType = "generates"
	EdgeTypeGeneratedFrom        EdgeType = "generatedFrom"
	EdgeTypeMetafile             EdgeType = "metafile"
	EdgeTypeOptionalComponent    EdgeType = "optionalComponent"
	EdgeTypeOptionalDependency   EdgeType = "optionalDependency"
	EdgeTypeOther                EdgeType = "other"
	EdgeTypePackages             EdgeType = "packages"
	EdgeTypePatch                EdgeType = "patch"
	EdgeTypePrerequisite         EdgeType = "prerequisite"
	EdgeTypePrerequisiteFor      EdgeType = "prerequisiteFor"
	EdgeTypeProvidedDependency   EdgeType = "providedDependency"
	EdgeTypeRequirementFor       EdgeType = "requirementFor"
	EdgeTypeRuntimeDependency    EdgeType = "runtimeDependency"
	EdgeTypeSpecificationFor     EdgeType = "specificationFor"
	EdgeTypeStaticLink           EdgeType = "staticLink"
	EdgeTypeTest                 EdgeType = "test"
	EdgeTypeTestCase             EdgeType = "testCase"
	EdgeTypeTestDependency       EdgeType = "testDependency"
	EdgeTypeTestTool             EdgeType = "testTool"
	EdgeTypeVariant              EdgeType = "variant"
)

func (et EdgeType) String() string {
	return string(et)
}

// EdgeTypeValidator is a validator for the "edge_type" field enum values. It is called by the builders before save.
func EdgeTypeValidator(et EdgeType) error {
	switch et {
	case EdgeTypeUNKNOWN, EdgeTypeAmends, EdgeTypeAncestor, EdgeTypeBuildDependency, EdgeTypeBuildTool, EdgeTypeContains, EdgeTypeContainedBy, EdgeTypeCopy, EdgeTypeDataFile, EdgeTypeDependencyManifest, EdgeTypeDependsOn, EdgeTypeDependencyOf, EdgeTypeDescendant, EdgeTypeDescribes, EdgeTypeDescribedBy, EdgeTypeDevDependency, EdgeTypeDevTool, EdgeTypeDistributionArtifact, EdgeTypeDocumentation, EdgeTypeDynamicLink, EdgeTypeExample, EdgeTypeExpandedFromArchive, EdgeTypeFileAdded, EdgeTypeFileDeleted, EdgeTypeFileModified, EdgeTypeGenerates, EdgeTypeGeneratedFrom, EdgeTypeMetafile, EdgeTypeOptionalComponent, EdgeTypeOptionalDependency, EdgeTypeOther, EdgeTypePackages, EdgeTypePatch, EdgeTypePrerequisite, EdgeTypePrerequisiteFor, EdgeTypeProvidedDependency, EdgeTypeRequirementFor, EdgeTypeRuntimeDependency, EdgeTypeSpecificationFor, EdgeTypeStaticLink, EdgeTypeTest, EdgeTypeTestCase, EdgeTypeTestDependency, EdgeTypeTestTool, EdgeTypeVariant:
		return nil
	default:
		return fmt.Errorf("node: invalid enum value for edge_type field: %q", et)
	}
}

// OrderOption defines the ordering options for the Node queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByFromNodeID orders the results by the from_node_id field.
func ByFromNodeID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFromNodeID, opts...).ToFunc()
}

// ByNodeListID orders the results by the node_list_id field.
func ByNodeListID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNodeListID, opts...).ToFunc()
}

// ByType orders the results by the type field.
func ByType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldType, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// ByVersion orders the results by the version field.
func ByVersion(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldVersion, opts...).ToFunc()
}

// ByFileName orders the results by the file_name field.
func ByFileName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFileName, opts...).ToFunc()
}

// ByURLHome orders the results by the url_home field.
func ByURLHome(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURLHome, opts...).ToFunc()
}

// ByURLDownload orders the results by the url_download field.
func ByURLDownload(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldURLDownload, opts...).ToFunc()
}

// ByLicenseConcluded orders the results by the license_concluded field.
func ByLicenseConcluded(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLicenseConcluded, opts...).ToFunc()
}

// ByLicenseComments orders the results by the license_comments field.
func ByLicenseComments(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldLicenseComments, opts...).ToFunc()
}

// ByCopyright orders the results by the copyright field.
func ByCopyright(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCopyright, opts...).ToFunc()
}

// BySourceInfo orders the results by the source_info field.
func BySourceInfo(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSourceInfo, opts...).ToFunc()
}

// ByComment orders the results by the comment field.
func ByComment(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldComment, opts...).ToFunc()
}

// BySummary orders the results by the summary field.
func BySummary(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSummary, opts...).ToFunc()
}

// ByDescription orders the results by the description field.
func ByDescription(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDescription, opts...).ToFunc()
}

// ByReleaseDate orders the results by the release_date field.
func ByReleaseDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldReleaseDate, opts...).ToFunc()
}

// ByBuildDate orders the results by the build_date field.
func ByBuildDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBuildDate, opts...).ToFunc()
}

// ByValidUntilDate orders the results by the valid_until_date field.
func ByValidUntilDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldValidUntilDate, opts...).ToFunc()
}

// ByEdgeType orders the results by the edge_type field.
func ByEdgeType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEdgeType, opts...).ToFunc()
}

// BySuppliersCount orders the results by suppliers count.
func BySuppliersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSuppliersStep(), opts...)
	}
}

// BySuppliers orders the results by suppliers terms.
func BySuppliers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSuppliersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByOriginatorsCount orders the results by originators count.
func ByOriginatorsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newOriginatorsStep(), opts...)
	}
}

// ByOriginators orders the results by originators terms.
func ByOriginators(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newOriginatorsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByExternalReferencesCount orders the results by external_references count.
func ByExternalReferencesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newExternalReferencesStep(), opts...)
	}
}

// ByExternalReferences orders the results by external_references terms.
func ByExternalReferences(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newExternalReferencesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByIdentifiersCount orders the results by identifiers count.
func ByIdentifiersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newIdentifiersStep(), opts...)
	}
}

// ByIdentifiers orders the results by identifiers terms.
func ByIdentifiers(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newIdentifiersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByHashesCount orders the results by hashes count.
func ByHashesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newHashesStep(), opts...)
	}
}

// ByHashes orders the results by hashes terms.
func ByHashes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newHashesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPrimaryPurposeCount orders the results by primary_purpose count.
func ByPrimaryPurposeCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPrimaryPurposeStep(), opts...)
	}
}

// ByPrimaryPurpose orders the results by primary_purpose terms.
func ByPrimaryPurpose(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPrimaryPurposeStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByFromNodeField orders the results by from_node field.
func ByFromNodeField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFromNodeStep(), sql.OrderByField(field, opts...))
	}
}

// ByNodesCount orders the results by nodes count.
func ByNodesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newNodesStep(), opts...)
	}
}

// ByNodes orders the results by nodes terms.
func ByNodes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newNodesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByNodeListField orders the results by node_list field.
func ByNodeListField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newNodeListStep(), sql.OrderByField(field, opts...))
	}
}
func newSuppliersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SuppliersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, SuppliersTable, SuppliersColumn),
	)
}
func newOriginatorsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(OriginatorsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, OriginatorsTable, OriginatorsColumn),
	)
}
func newExternalReferencesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ExternalReferencesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, ExternalReferencesTable, ExternalReferencesColumn),
	)
}
func newIdentifiersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(IdentifiersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, IdentifiersTable, IdentifiersColumn),
	)
}
func newHashesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(HashesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, HashesTable, HashesColumn),
	)
}
func newPrimaryPurposeStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PrimaryPurposeInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, PrimaryPurposeTable, PrimaryPurposeColumn),
	)
}
func newFromNodeStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(Table, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, FromNodeTable, FromNodeColumn),
	)
}
func newNodesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(Table, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, NodesTable, NodesColumn),
	)
}
func newNodeListStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(NodeListInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, NodeListTable, NodeListColumn),
	)
}
